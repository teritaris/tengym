"use strict";
/*
 * Copyright 2018 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.MosaicRestrictionTransactionService = void 0;
const rxjs_1 = require("rxjs");
const operators_1 = require("rxjs/operators");
const model_1 = require("../model");
const MosaicId_1 = require("../model/mosaic/MosaicId");
const MosaicRestrictionType_1 = require("../model/restriction/MosaicRestrictionType");
const MosaicAddressRestrictionTransaction_1 = require("../model/transaction/MosaicAddressRestrictionTransaction");
const MosaicGlobalRestrictionTransaction_1 = require("../model/transaction/MosaicGlobalRestrictionTransaction");
const UInt64_1 = require("../model/UInt64");
/**
 * MosaicRestrictionTransactionService service
 */
class MosaicRestrictionTransactionService {
    /**
     * Constructor
     * @param restrictionMosaicRepository
     * @param namespaceRepository
     */
    constructor(restrictionMosaicRepository, namespaceRepository) {
        this.restrictionMosaicRepository = restrictionMosaicRepository;
        this.namespaceRepository = namespaceRepository;
        this.defaultMosaicAddressRestrictionValue = UInt64_1.UInt64.fromHex('FFFFFFFFFFFFFFFF');
        this.defaultMosaicGlobalRestrictionValue = UInt64_1.UInt64.fromUint(0);
    }
    /**
     * Create a MosaicGlobalRestrictionTransaction object without previous restriction data
     * @param deadline - Deadline
     * @param networkType - Network identifier
     * @param mosaicId - Unresolved mosaicId
     * @param restrictionKey - Restriction key
     * @param restrictionValue - New restriction value
     * @param restrictionType - New restriction type
     * @param referenceMosaicId - Reference mosaic Id
     * @param maxFee - Max fee
     */
    createMosaicGlobalRestrictionTransaction(deadline, networkType, mosaicId, restrictionKey, restrictionValue, restrictionType, referenceMosaicId = new MosaicId_1.MosaicId(UInt64_1.UInt64.fromUint(0).toDTO()), maxFee = new UInt64_1.UInt64([0, 0])) {
        this.validateInput(restrictionValue);
        return this.getResolvedMosaicId(mosaicId).pipe(operators_1.mergeMap((resolvedMosaicId) => this.getGlobalRestrictionEntry(resolvedMosaicId, restrictionKey).pipe(operators_1.map((restrictionEntry) => {
            const currentValue = restrictionEntry
                ? restrictionEntry.restrictionValue
                : this.defaultMosaicGlobalRestrictionValue;
            const currentType = restrictionEntry ? restrictionEntry.restrictionType : MosaicRestrictionType_1.MosaicRestrictionType.NONE;
            return MosaicGlobalRestrictionTransaction_1.MosaicGlobalRestrictionTransaction.create(deadline, resolvedMosaicId, restrictionKey, currentValue, currentType, UInt64_1.UInt64.fromNumericString(restrictionValue), restrictionType, networkType, referenceMosaicId, maxFee);
        }))));
    }
    /**
     * Create a MosaicAddressRestrictionTransaction object without previous restriction data
     * @param deadline - Deadline
     * @param networkType - Network identifier
     * @param mosaicId - Unresolved mosaicId
     * @param restrictionKey - Restriction key
     * @param targetAddress - Unresolved target address
     * @param restrictionValue - New restriction value
     * @param maxFee - Max fee
     */
    createMosaicAddressRestrictionTransaction(deadline, networkType, mosaicId, restrictionKey, targetAddress, restrictionValue, maxFee = new UInt64_1.UInt64([0, 0])) {
        this.validateInput(restrictionValue);
        const combinedUnresolved = rxjs_1.combineLatest([this.getResolvedMosaicId(mosaicId), this.getResolvedAddress(targetAddress)]);
        return combinedUnresolved.pipe(operators_1.mergeMap(([resolvedMosaicId, resolvedAddress]) => this.getGlobalRestrictionEntry(resolvedMosaicId, restrictionKey).pipe(operators_1.mergeMap((restrictionEntry) => {
            if (!restrictionEntry) {
                throw new Error(`Global restriction for mosaic: ${mosaicId.toHex()} is not valid for with RestrictionKey: ${restrictionKey}`);
            }
            return this.getAddressRestrictionEntry(resolvedMosaicId, restrictionKey, resolvedAddress).pipe(operators_1.map((optionalValue) => {
                const currentValue = optionalValue || this.defaultMosaicAddressRestrictionValue;
                return MosaicAddressRestrictionTransaction_1.MosaicAddressRestrictionTransaction.create(deadline, mosaicId, restrictionKey, targetAddress, UInt64_1.UInt64.fromNumericString(restrictionValue), networkType, currentValue, maxFee);
            }));
        }))));
    }
    /**
     * Get address global restriction previous value and type
     * @param mosaicId - Mosaic identifier
     * @param restrictionKey - Mosaic global restriction key
     * @param targetAddress - The target address
     * @return {Observable<string | undefined>}
     */
    getAddressRestrictionEntry(mosaicId, restrictionKey, targetAddress) {
        return this.restrictionMosaicRepository.search({ mosaicId, targetAddress, entryType: model_1.MosaicRestrictionEntryType.ADDRESS }).pipe(operators_1.map((mosaicRestriction) => {
            var _a;
            const addressRestriction = mosaicRestriction.data.find((r) => r.entryType == model_1.MosaicRestrictionEntryType.ADDRESS &&
                r.mosaicId.equals(mosaicId) &&
                r.targetAddress.equals(targetAddress));
            return addressRestriction ? (_a = addressRestriction.getRestriction(restrictionKey)) === null || _a === void 0 ? void 0 : _a.restrictionValue : undefined;
        }));
    }
    /**
     * Get mosaic global restriction prvious value and type
     * @param mosaicId - Mosaic identifier
     * @param restrictionKey - Mosaic global restriction key
     * @return {Observable<MosaicGlobalRestrictionItem | undefined>}
     */
    getGlobalRestrictionEntry(mosaicId, restrictionKey) {
        return this.restrictionMosaicRepository.search({ mosaicId, entryType: model_1.MosaicRestrictionEntryType.GLOBAL }).pipe(operators_1.map((mosaicRestrictionPage) => {
            const globalRestriction = mosaicRestrictionPage.data.find((r) => r.entryType == model_1.MosaicRestrictionEntryType.GLOBAL && r.mosaicId.equals(mosaicId));
            return globalRestriction ? globalRestriction.getRestriction(restrictionKey) : undefined;
        }));
    }
    /**
     * Check if input restriction key and value are invalid or not
     * @param value - Restriction value
     */
    validateInput(value) {
        if (!UInt64_1.UInt64.isLongNumericString(value)) {
            throw new Error(`RestrictionValue: ${value} is not a valid numeric string.`);
        }
    }
    /**
     * @internal
     * Get resolved mosaicId from namespace repository
     * @param unresolvedMosaicId unresolved mosaicId
     * @returns {MosaicId}
     */
    getResolvedMosaicId(unresolvedMosaicId) {
        if (!unresolvedMosaicId.isNamespaceId()) {
            return rxjs_1.of(unresolvedMosaicId);
        }
        const namespaceId = unresolvedMosaicId;
        return this.namespaceRepository.getLinkedMosaicId(namespaceId).pipe(operators_1.map((mosaicId) => {
            if (!mosaicId) {
                throw new Error(`Invalid unresolvedMosaicId: ${unresolvedMosaicId.toHex()}`);
            }
            return mosaicId;
        }), operators_1.catchError((err) => {
            throw new Error(err);
        }));
    }
    /**
     * @internal
     * Get resolved address from namespace repository
     * @param unresolvedAddress unresolved address
     * @returns {Address}
     */
    getResolvedAddress(unresolvedAddress) {
        if (!unresolvedAddress.isNamespaceId()) {
            return rxjs_1.of(unresolvedAddress);
        }
        const namespaceId = unresolvedAddress;
        return this.namespaceRepository.getLinkedAddress(namespaceId).pipe(operators_1.map((address) => {
            if (!address) {
                throw new Error(`Invalid unresolvedAddress: ${namespaceId.toHex()}`);
            }
            return address;
        }), operators_1.catchError((err) => {
            throw new Error(err);
        }));
    }
}
exports.MosaicRestrictionTransactionService = MosaicRestrictionTransactionService;
//# sourceMappingURL=MosaicRestrictionTransactionService.js.map